#pragma kernel ErodeGrains
#pragma kernel DepositGrains  
#pragma kernel RunAvalanche

// Buffers
RWStructuredBuffer<float> sandHeights;
StructuredBuffer<float> terrainShadow;
StructuredBuffer<int> shadow;
StructuredBuffer<int> constructionGrid;
StructuredBuffer<ConstructionData> constructionData;
RWStructuredBuffer<uint> randomSeeds;
RWStructuredBuffer<CellChange> changes;

// Parámetros
int width, height;
int windDx, windDz;
float erosionHeight, depositeHeight;
int grainsPerStep;
int hopLength;
float slopeThreshold;
float pSand, pNoSand;

// Estructuras
struct ConstructionData
{
    float buildHeight;
    int active;
};

struct CellChange
{
    int x;
    int z;
    int changed;
};

// Función de random optimizada para GPU
uint rng_state;

uint rand_xorshift()
{
    rng_state ^= rng_state << 13;
    rng_state ^= rng_state >> 17;
    rng_state ^= rng_state << 5;
    return rng_state;
}

float rand_float()
{
    return float(rand_xorshift()) / 4294967296.0;
}

int rand_int(int minVal, int maxVal)
{
    return minVal + int(rand_float() * (maxVal - minVal));
}

// Función auxiliar para índices
int GetIndex(int x, int z)
{
    return z * width + x;
}

bool IsValidCell(int x, int z)
{
    return x >= 0 && x < width && z >= 0 && z < height;
}

// Erosión de granos - adaptación directa de tu ErodeGrain
float ErodeGrain(int x, int z)
{
    int index = GetIndex(x, z);
    
    // Condición original: si está en sombra o no hay arena sobre terreno
    if (shadow[index] > 0 || terrainShadow[index] >= sandHeights[index] - erosionHeight * 0.1f)
        return 0.0f;
    
    float availableSand = sandHeights[index] - terrainShadow[index];
    float eroded = min(erosionHeight, availableSand);
    
    if (eroded > 0)
    {
        sandHeights[index] -= eroded;
    }
    
    return eroded;
}

// Deposición de granos
void DepositGrain(int x, int z, float amount)
{
    if (IsValidCell(x, z))
    {
        int index = GetIndex(x, z);
        sandHeights[index] += amount;
    }
}

// Algoritmo de deposición - adaptación directa de tu AlgorithmDeposit
void AlgorithmDeposit(int startX, int startZ, int dx, int dz, float depositeH, int threadId)
{
    int i = hopLength;
    int xCurr = startX;
    int zCurr = startZ;
    
    // Conteo inicial de terrain (tu lógica original)
    int countTerrain = 0;
    for (int j = 1; j <= i; j++)
    {
        int xAux = xCurr + j * dx;
        int zAux = zCurr + j * dz;
        
        if (IsValidCell(xAux, zAux))
        {
            if (terrainShadow[GetIndex(xAux, zAux)] >= sandHeights[GetIndex(xAux, zAux)])
                countTerrain++;
        }
    }
    
    int maxIterations = 2000; // Prevenir bucles infinitos en GPU
    int iterations = 0;
    
    while (iterations < maxIterations)
    {
        iterations++;
        
        #region Barlovento behaviour with structures
        // Tu lógica original de estructuras
        int steps = max(abs(dx), abs(dz));
        if (steps > 0)
        {
            int stepX = (steps > 0) ? dx / steps : 0;
            int stepZ = (steps > 0) ? dz / steps : 0;
            
            for (int s = 1; s <= steps; s++)
            {
                int checkX = xCurr + s * stepX + dx;
                int checkZ = zCurr + s * stepZ + dz;
                
                if (IsValidCell(checkX, checkZ))
                {
                    int constructionId = constructionGrid[GetIndex(checkX, checkZ)];
                    
                    // Verificar si hay construcción válida
                    if (constructionId > 0 && constructionId < 1000)
                    {
                        ConstructionData currentConstruction = constructionData[constructionId];
                        
                        if (currentConstruction.active > 0)
                        {
                            int xPrev = checkX - dx;
                            int zPrev = checkZ - dz;
                            
                            if (IsValidCell(xPrev, zPrev))
                            {
                                float acumulacionBarlovento = terrainShadow[GetIndex(checkX, checkZ)] - 
                                                            sandHeights[GetIndex(xPrev, zPrev)];
                                
                                if (acumulacionBarlovento <= currentConstruction.buildHeight * 0.1f)
                                {
                                    DepositGrain(checkX, checkZ, depositeH);
                                    changes[threadId].x = checkX;
                                    changes[threadId].z = checkZ;
                                    changes[threadId].changed = 1;
                                    return;
                                }
                                else
                                {
                                    int stopX = xCurr + (s - 1) * stepX;
                                    int stopZ = zCurr + (s - 1) * stepZ;
                                    DepositGrain(stopX, stopZ, depositeH);
                                    changes[threadId].x = stopX;
                                    changes[threadId].z = stopZ;
                                    changes[threadId].changed = 1;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
        #endregion
        
        #region Open field behaviour
        // Tu lógica original de campo abierto
        xCurr += dx;
        zCurr += dz;
        
        if (!IsValidCell(xCurr, zCurr)) break;
        
        int currIndex = GetIndex(xCurr, zCurr);
        
        // Deposición en zona de sombra
        if (shadow[currIndex] > 0 && sandHeights[currIndex] > terrainShadow[currIndex])
        {
            DepositGrain(xCurr, zCurr, depositeH);
            changes[threadId].x = xCurr;
            changes[threadId].z = zCurr;
            changes[threadId].changed = 1;
            return;
        }
        
        // Lógica de terrain (tu condición original)
        if (terrainShadow[currIndex] >= sandHeights[currIndex] &&
            terrainShadow[currIndex] >= sandHeights[GetIndex(startX, startZ)])
        {
            countTerrain -= (terrainShadow[currIndex] >= sandHeights[currIndex]) ? 1 : 0;
            continue;
        }
        
        // Deposición lateral cuando hay mucho terrain (tu lógica original)
        if (countTerrain >= i - 1)
        {
            int dxLateral[2] = {-dz, dz};
            int dzLateral[2] = {dx, -dx};
            
            for (int j = 0; j < 2; j++)
            {
                for (int k = 1; k <= i; k++)
                {
                    int lx = xCurr + dxLateral[j] * k;
                    int lz = zCurr + dzLateral[j] * k;
                    
                    if (IsValidCell(lx, lz))
                    {
                        int lIndex = GetIndex(lx, lz);
                        float heightL = max(terrainShadow[lIndex], sandHeights[lIndex]);
                        float heightCurr = max(terrainShadow[currIndex], sandHeights[currIndex]);
                        
                        if (heightL < heightCurr - slopeThreshold)
                        {
                            DepositGrain(lx, lz, depositeH);
                            changes[threadId].x = lx;
                            changes[threadId].z = lz;
                            changes[threadId].changed = 1;
                            return;
                        }
                    }
                }
            }
        }
        
        countTerrain -= (terrainShadow[currIndex] >= sandHeights[currIndex]) ? 1 : 0;
        
        // Lógica de hop length (tu lógica original)
        if (--i <= 0)
        {
            float prob = (sandHeights[currIndex] > terrainShadow[currIndex]) ? pSand : pNoSand;
            
            if (rand_float() < prob)
            {
                DepositGrain(xCurr, zCurr, depositeH);
                changes[threadId].x = xCurr;
                changes[threadId].z = zCurr;
                changes[threadId].changed = 1;
                return;
            }
            i = hopLength;
        }
        #endregion
    }
    
    // Si llegamos aquí sin depositar, depositar en posición actual
    DepositGrain(xCurr, zCurr, depositeH);
    changes[threadId].x = xCurr;
    changes[threadId].z = zCurr;
    changes[threadId].changed = 1;
}

// Kernel principal de erosión - ejecuta tu función Tick
[numthreads(64, 1, 1)]
void ErodeGrains(uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= grainsPerStep) return;
    
    // Inicializar estado de random único por thread
    rng_state = randomSeeds[id.x] + id.x + 1;
    
    // Seleccionar posición aleatoria (tu lógica original)
    int x = rand_int(0, width);
    int z = rand_int(0, height);
    
    int index = GetIndex(x, z);
    
    // Verificar condición de sombra (tu condición original)
    if (shadow[index] > 0 || terrainShadow[index] >= sandHeights[index] - erosionHeight * 0.1f)
    {
        // Actualizar semilla para próximo uso
        randomSeeds[id.x] = rng_state;
        return;
    }
    
    // Erosionar grano
    float depositeH = ErodeGrain(x, z);
    
    if (depositeH > 0.0f)
    {
        // Ejecutar algoritmo de deposición
        AlgorithmDeposit(x, z, windDx, windDz, depositeH, (int)id.x);
    }
    
    // Actualizar semilla para próximo uso
    randomSeeds[id.x] = rng_state;
}

// Kernel secundario para procesos post-deposición
[numthreads(64, 1, 1)]
void DepositGrains(uint3 id : SV_DispatchThreadID)
{
    // Este kernel puede usarse para procesos adicionales después de la deposición
    // Como normalización de alturas, cálculo de sombras, etc.
    
    if ((int)id.x >= grainsPerStep) return;
    
    // Procesar cambios registrados
    if (changes[id.x].changed > 0)
    {
        int x = changes[id.x].x;
        int z = changes[id.x].z;
        
        // Aquí puedes agregar lógica adicional como:
        // - Actualización de sombras locales
        // - Verificación de estabilidad
        // - Marcado de áreas para re-render
        
        // Reset del cambio
        changes[id.x].changed = 0;
    }
}

// Kernel de avalancha - implementa tu RunAvalancheBurst
[numthreads(8, 8, 1)]
void RunAvalanche(uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x;
    int z = (int)id.y;
    
    if (!IsValidCell(x, z)) return;
    
    int index = GetIndex(x, z);
    
    float currentHeight = sandHeights[index];
    float terrainHeight = terrainShadow[index];
    
    // Solo procesar celdas con arena
    if (currentHeight <= terrainHeight + 0.001f) return;
    
    // Verificar estabilidad con vecinos (implementar tu lógica de avalancha)
    float maxSlope = 0.0f;
    int bestX = x, bestZ = z;
    
    // Revisar vecinos en patrón de 3x3
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dz = -1; dz <= 1; dz++)
        {
            if (dx == 0 && dz == 0) continue;
            
            int nx = x + dx;
            int nz = z + dz;
            
            if (IsValidCell(nx, nz))
            {
                int nIndex = GetIndex(nx, nz);
                float neighborHeight = max(sandHeights[nIndex], terrainShadow[nIndex]);
                float currentTotalHeight = max(currentHeight, terrainHeight);
                float slope = currentTotalHeight - neighborHeight;
                
                // Usar tu slopeThreshold
                if (slope > slopeThreshold && slope > maxSlope)
                {
                    maxSlope = slope;
                    bestX = nx;
                    bestZ = nz;
                }
            }
        }
    }
    
    // Realizar avalancha si es necesario
    if (maxSlope > slopeThreshold)
    {
        float transfer = min(maxSlope * 0.1f, currentHeight - terrainHeight);
        transfer = min(transfer, currentHeight * 0.5f); // Limitar transferencia
        
        if (transfer > 0.001f)
        {
            // Transferencia atómica para evitar condiciones de carrera
            InterlockedAdd(sandHeights[index], -transfer);
            InterlockedAdd(sandHeights[GetIndex(bestX, bestZ)], transfer);
        }
    }
}