#pragma kernel ErodeGrains
#pragma kernel DepositGrains  
#pragma kernel RunAvalanche

// Buffers
RWStructuredBuffer<float> sandHeights;
StructuredBuffer<float> terrainShadow;
StructuredBuffer<int> shadow;
StructuredBuffer<int> constructionGrid;
StructuredBuffer<ConstructionData> constructionData;
RWStructuredBuffer<uint> randomSeeds;
RWStructuredBuffer<CellChange> changes;

// Parámetros
int width, height;
int windDx, windDz;
float erosionHeight, depositeHeight;
int grainsPerStep;
int hopLength;
float slopeThreshold;
float pSand, pNoSand;

// Estructuras
struct ConstructionData
{
    float buildHeight;
    int active;
};

struct CellChange
{
    int x;
    int z;
    int changed;
};

// Estado de random por thread
static uint rng_state;

// Función de random optimizada para GPU
uint rand_xorshift()
{
    rng_state ^= rng_state << 13;
    rng_state ^= rng_state >> 17;
    rng_state ^= rng_state << 5;
    return rng_state;
}

float rand_float()
{
    return float(rand_xorshift()) * (1.0 / 4294967296.0);
}

int rand_int(int minVal, int maxVal)
{
    return minVal + int(rand_float() * (maxVal - minVal));
}

// Función auxiliar para índices
int GetIndex(int x, int z)
{
    return z * width + x;
}

bool IsValidCell(int x, int z)
{
    return x >= 0 && x < width && z >= 0 && z < height;
}

// Erosión de granos
float ErodeGrain(int x, int z)
{
    int index = GetIndex(x, z);
    
    if (shadow[index] > 0 || terrainShadow[index] >= sandHeights[index] - erosionHeight * 0.1)
        return 0.0;
    
    float availableSand = sandHeights[index] - terrainShadow[index];
    float eroded = min(erosionHeight, availableSand);
    
    if (eroded > 0)
    {
        sandHeights[index] -= eroded;
    }
    
    return eroded;
}

// Deposición de granos
void DepositGrain(int x, int z, float amount)
{
    if (IsValidCell(x, z))
    {
        int index = GetIndex(x, z);
        sandHeights[index] += amount;
    }
}

// Algoritmo de deposición
void AlgorithmDeposit(int startX, int startZ, int dx, int dz, float depositeH, int threadId)
{
    int i = hopLength;
    int xCurr = startX;
    int zCurr = startZ;
    
    // Conteo inicial de terrain
    int countTerrain = 0;
    for (int j = 1; j <= i; j++)
    {
        int xAux = xCurr + j * dx;
        int zAux = zCurr + j * dz;
        
        if (IsValidCell(xAux, zAux))
        {
            if (terrainShadow[GetIndex(xAux, zAux)] >= sandHeights[GetIndex(xAux, zAux)])
                countTerrain++;
        }
    }
    
    int maxIterations = 1000;
    int iterations = 0;
    
    [loop]
    while (iterations < maxIterations)
    {
        iterations++;
        
        // Comportamiento con estructuras
        int steps = max(abs(dx), abs(dz));
        if (steps > 0)
        {
            int stepX = (dx != 0) ? dx / steps : 0;
            int stepZ = (dz != 0) ? dz / steps : 0;
            
            for (int s = 1; s <= steps; s++)
            {
                int checkX = xCurr + s * stepX + dx;
                int checkZ = zCurr + s * stepZ + dz;
                
                if (IsValidCell(checkX, checkZ))
                {
                    int constructionId = constructionGrid[GetIndex(checkX, checkZ)];
                    
                    if (constructionId > 0 && constructionId < 1000)
                    {
                        ConstructionData currentConstruction = constructionData[constructionId];
                        
                        if (currentConstruction.active > 0)
                        {
                            int xPrev = checkX - dx;
                            int zPrev = checkZ - dz;
                            
                            if (IsValidCell(xPrev, zPrev))
                            {
                                float acumulacionBarlovento = terrainShadow[GetIndex(checkX, checkZ)] - 
                                                            sandHeights[GetIndex(xPrev, zPrev)];
                                
                                if (acumulacionBarlovento <= currentConstruction.buildHeight * 0.1)
                                {
                                    DepositGrain(checkX, checkZ, depositeH);
                                    if (threadId < grainsPerStep)
                                    {
                                        changes[threadId].x = checkX;
                                        changes[threadId].z = checkZ;
                                        changes[threadId].changed = 1;
                                    }
                                    return;
                                }
                                else
                                {
                                    int stopX = xCurr + (s - 1) * stepX;
                                    int stopZ = zCurr + (s - 1) * stepZ;
                                    DepositGrain(stopX, stopZ, depositeH);
                                    if (threadId < grainsPerStep)
                                    {
                                        changes[threadId].x = stopX;
                                        changes[threadId].z = stopZ;
                                        changes[threadId].changed = 1;
                                    }
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Comportamiento de campo abierto
        xCurr += dx;
        zCurr += dz;
        
        if (!IsValidCell(xCurr, zCurr)) break;
        
        int currIndex = GetIndex(xCurr, zCurr);
        
        // Deposición en zona de sombra
        if (shadow[currIndex] > 0 && sandHeights[currIndex] > terrainShadow[currIndex])
        {
            DepositGrain(xCurr, zCurr, depositeH);
            if (threadId < grainsPerStep)
            {
                changes[threadId].x = xCurr;
                changes[threadId].z = zCurr;
                changes[threadId].changed = 1;
            }
            return;
        }
        
        // Lógica de terrain
        if (terrainShadow[currIndex] >= sandHeights[currIndex] &&
            terrainShadow[currIndex] >= sandHeights[GetIndex(startX, startZ)])
        {
            countTerrain -= (terrainShadow[currIndex] >= sandHeights[currIndex]) ? 1 : 0;
            continue;
        }
        
        // Deposición lateral cuando hay mucho terrain
        if (countTerrain >= i - 1)
        {
            int dxLateral[2];
            int dzLateral[2];
            
            dxLateral[0] = -dz;
            dxLateral[1] = dz;
            dzLateral[0] = dx;
            dzLateral[1] = -dx;
            
            for (int j = 0; j < 2; j++)
            {
                for (int k = 1; k <= i; k++)
                {
                    int lx = xCurr + dxLateral[j] * k;
                    int lz = zCurr + dzLateral[j] * k;
                    
                    if (IsValidCell(lx, lz))
                    {
                        int lIndex = GetIndex(lx, lz);
                        float heightL = max(terrainShadow[lIndex], sandHeights[lIndex]);
                        float heightCurr = max(terrainShadow[currIndex], sandHeights[currIndex]);
                        
                        if (heightL < heightCurr - slopeThreshold)
                        {
                            DepositGrain(lx, lz, depositeH);
                            if (threadId < grainsPerStep)
                            {
                                changes[threadId].x = lx;
                                changes[threadId].z = lz;
                                changes[threadId].changed = 1;
                            }
                            return;
                        }
                    }
                }
            }
        }
        
        countTerrain -= (terrainShadow[currIndex] >= sandHeights[currIndex]) ? 1 : 0;
        
        // Lógica de hop length
        if (--i <= 0)
        {
            float prob = (sandHeights[currIndex] > terrainShadow[currIndex]) ? pSand : pNoSand;
            
            if (rand_float() < prob)
            {
                DepositGrain(xCurr, zCurr, depositeH);
                if (threadId < grainsPerStep)
                {
                    changes[threadId].x = xCurr;
                    changes[threadId].z = zCurr;
                    changes[threadId].changed = 1;
                }
                return;
            }
            i = hopLength;
        }
    }
    
    // Depositar en posición actual como último recurso
    DepositGrain(xCurr, zCurr, depositeH);
    if (threadId < grainsPerStep)
    {
        changes[threadId].x = xCurr;
        changes[threadId].z = zCurr;
        changes[threadId].changed = 1;
    }
}

// Kernel principal de erosión
[numthreads(64, 1, 1)]
void ErodeGrains(uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= grainsPerStep) return;
    
    // Inicializar estado de random único por thread
    rng_state = randomSeeds[id.x] + id.x + 1;
    
    // Seleccionar posición aleatoria
    int x = rand_int(0, width);
    int z = rand_int(0, height);
    
    int index = GetIndex(x, z);
    
    // Verificar condición de sombra
    if (shadow[index] > 0 || terrainShadow[index] >= sandHeights[index] - erosionHeight * 0.1)
    {
        randomSeeds[id.x] = rng_state;
        return;
    }
    
    // Erosionar grano
    float depositeH = ErodeGrain(x, z);
    
    if (depositeH > 0.0)
    {
        // Ejecutar algoritmo de deposición
        AlgorithmDeposit(x, z, windDx, windDz, depositeH, (int)id.x);
    }
    
    // Actualizar semilla para próximo uso
    randomSeeds[id.x] = rng_state;
}

// Kernel para procesos post-deposición
[numthreads(64, 1, 1)]
void DepositGrains(uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= grainsPerStep) return;
    
    // Procesar cambios registrados
    if (changes[id.x].changed > 0)
    {
        // Reset del cambio
        changes[id.x].changed = 0;
    }
}

// Kernel de avalancha
[numthreads(8, 8, 1)]
void RunAvalanche(uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x;
    int z = (int)id.y;
    
    if (!IsValidCell(x, z)) return;
    
    int index = GetIndex(x, z);
    
    float currentHeight = sandHeights[index];
    float terrainHeight = terrainShadow[index];
    
    // Solo procesar celdas con arena
    if (currentHeight <= terrainHeight + 0.001) return;
    
    // Verificar estabilidad con vecinos
    float maxSlope = 0.0;
    int bestX = x;
    int bestZ = z;
    
    // Revisar vecinos en patrón de 3x3
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dz = -1; dz <= 1; dz++)
        {
            if (dx == 0 && dz == 0) continue;
            
            int nx = x + dx;
            int nz = z + dz;
            
            if (IsValidCell(nx, nz))
            {
                int nIndex = GetIndex(nx, nz);
                float neighborHeight = max(sandHeights[nIndex], terrainShadow[nIndex]);
                float currentTotalHeight = max(currentHeight, terrainHeight);
                float slope = currentTotalHeight - neighborHeight;
                
                if (slope > slopeThreshold && slope > maxSlope)
                {
                    maxSlope = slope;
                    bestX = nx;
                    bestZ = nz;
                }
            }
        }
    }
    
    // Realizar avalancha si es necesario
    if (maxSlope > slopeThreshold)
    {
        float transfer = min(maxSlope * 0.1, currentHeight - terrainHeight);
        transfer = min(transfer, currentHeight * 0.5);
        
        if (transfer > 0.001)
        {
            sandHeights[index] -= transfer;
            sandHeights[GetIndex(bestX, bestZ)] += transfer;
        }
    }
}